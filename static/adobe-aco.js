function T(r) { return (r & 65280) >> 8 | (r & 255) << 8 } function V(...r) { let t = new Uint8Array(r.reduce((i, n) => i + n.byteLength, 0)), e = 0; for (let i of r) t.set(new Uint8Array(i), e), e += i.byteLength; return t.buffer } function X(r) { return new TextEncoder().encode(r) } function R(r) { return new TextDecoder().decode(r) } function C(r, t = !1) { let e = new Uint16Array(r.length); for (let i = 0; i < r.length; i++) { let n = r.charCodeAt(i); e[i] = t ? n : T(n) } return e.buffer } function M(r, t = !1) { let e = new Uint16Array(r), i = ""; for (let n of e) i += String.fromCharCode(t ? n : T(n)); return i } function W(r, t = "utf8") { switch (t) { case "utf16le": return C(r, !0); case "utf16be": return C(r, !1); case "utf8": return X(r); default: throw new Error(`Unknown string encoding "${t}"`) } } function k(r, t = "utf8") { switch (t) { case "utf16le": return M(r, !0); case "utf16be": return M(r, !1); case "utf8": return R(r); default: throw new Error(`Unknown string encoding "${t}"`) } } function $(r) { switch (r) { case "utf8": return 1; case "utf16le": case "utf16be": return 2; default: throw new Error(`Unknown string encoding "${r}"`) } } var b = function (r, t, e, i, n) { if (i === "m") throw new TypeError("Private method is not writable"); if (i === "a" && !n) throw new TypeError("Private accessor was defined without a setter"); if (typeof t == "function" ? r !== t || !n : !t.has(r)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return i === "a" ? n.call(r, e) : n ? n.value = e : t.set(r, e), e }, p = function (r, t, e, i) { if (e === "a" && !i) throw new TypeError("Private accessor was defined without a getter"); if (typeof t == "function" ? r !== t || !i : !t.has(r)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return e === "m" ? i : e === "a" ? i.call(r) : i ? i.value : t.get(r) }, A, w, g, _ = class r { constructor(t) { A.set(this, void 0), w.set(this, 0), g.set(this, void 0), b(this, A, new DataView(t), "f") } get view() { return p(this, A, "f") } get position() { return p(this, w, "f") } get buffer() { return this.view.buffer } get byteLength() { return this.buffer.byteLength } at(t) { let e = new r(this.buffer); return e.setPosition(t), e } slice(t = 0, e = this.buffer.byteLength) { return new r(this.buffer.slice(t, e)) } read(t, e) { if (this.position + e > this.view.buffer.byteLength) throw new Error(`Reader is out of bounds. Tried to read ${e} bytes at offset ${this.position}, but the buffer is only ${this.view.buffer.byteLength} bytes long`); let i = t(this.position); return this.movePosition(e), i } readFloat32(t = !1) { return this.read(e => this.view.getFloat32(e, t), 4) } readFloat64(t = !1) { return this.read(e => this.view.getFloat64(e, t), 4) } readBigInt64(t = !1) { return this.read(e => this.view.getBigInt64(e, t), 8) } readBigUInt64(t = !1) { return this.read(e => this.view.getBigUint64(e, t), 8) } readInt32(t = !1) { return this.read(e => this.view.getInt32(e, t), 4) } readUint32(t = !1) { return this.read(e => this.view.getUint32(e, t), 4) } readInt16(t = !1) { return this.read(e => this.view.getInt16(e, t), 2) } readUint16(t = !1) { return this.read(e => this.view.getUint16(e, t), 2) } readInt8() { return this.read(t => this.view.getInt8(t), 1) } readUint8() { return this.read(t => this.view.getUint8(t), 1) } readString(t, e = "utf8") { return k(this.nextBytes(t * $(e)), e) } readBytesAsUInt(t, e = !1) { switch (t) { case 1: return this.readUint8(); case 2: return this.readUint16(e); case 4: return this.readUint32(e); case 8: return this.readBigUInt64(e); default: throw new Error(`Unknown integer byte length ${t}`) } } readBytesAsFloat(t, e = !1) { switch (t) { case 4: return this.readFloat32(e); case 8: return this.readFloat64(e); default: throw new Error(`Unknown float byte length ${t}`) } } nextBytes(t) { let e = this.view.buffer.slice(this.position, this.position + t); return this.movePosition(t), e } setPosition(t) { b(this, w, t, "f") } movePosition(t) { b(this, w, p(this, w, "f") + t, "f") } save() { p(this, g, "f") !== void 0 && console.warn("There already is a saved position!"), b(this, g, p(this, w, "f"), "f") } restore() { if (p(this, g, "f") === void 0) throw new Error("Position must be saved before it can be restored."); b(this, w, p(this, g, "f"), "f"), b(this, g, void 0, "f") } }; A = new WeakMap, w = new WeakMap, g = new WeakMap; var v = function (r, t, e, i, n) { if (i === "m") throw new TypeError("Private method is not writable"); if (i === "a" && !n) throw new TypeError("Private accessor was defined without a setter"); if (typeof t == "function" ? r !== t || !n : !t.has(r)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return i === "a" ? n.call(r, e) : n ? n.value = e : t.set(r, e), e }, c = function (r, t, e, i) { if (e === "a" && !i) throw new TypeError("Private accessor was defined without a getter"); if (typeof t == "function" ? r !== t || !i : !t.has(r)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return e === "m" ? i : e === "a" ? i.call(r) : i ? i.value : t.get(r) }, l, I, U, F = class { constructor() { l.set(this, void 0), I.set(this, void 0), U.set(this, 0), v(this, l, new ArrayBuffer(0), "f"), v(this, I, new DataView(c(this, l, "f")), "f") } get buffer() { return c(this, l, "f") } get view() { return c(this, I, "f").buffer !== c(this, l, "f") && v(this, I, new DataView(c(this, l, "f")), "f"), c(this, I, "f") } get position() { return c(this, U, "f") } movePointer(t) { v(this, U, c(this, U, "f") + t, "f") } setPointer(t) { v(this, U, t, "f") } enlarge(t) { v(this, l, V(c(this, l, "f"), new ArrayBuffer(t)), "f") } alloc(t) { this.view.byteLength < t && this.enlarge(t - this.view.byteLength) } write(t, e) { this.alloc(this.position + e), t(), this.movePointer(e) } writeInt8(t) { this.write(() => this.view.setInt8(this.position, t), 1) } writeUint8(t) { this.write(() => this.view.setUint8(this.position, t), 1) } writeInt16(t, e = !1) { this.write(() => this.view.setInt16(this.position, t, e), 2) } writeUint16(t, e = !1) { this.write(() => this.view.setUint16(this.position, t, e), 2) } writeInt32(t, e = !1) { this.write(() => this.view.setInt32(this.position, t, e), 4) } writeUint32(t, e = !1) { this.write(() => this.view.setUint32(this.position, t, e), 4) } writeString(t, e) { this.writeBytes(W(t, e)) } writeBytes(t) { this.write(() => { new Uint8Array(this.buffer).set(new Uint8Array(t), this.position) }, t.byteLength) } }; l = new WeakMap, I = new WeakMap, U = new WeakMap; var h = class r extends Error { constructor(t) { super(t), this.name = "AcoFileError" } static WrongVersionNumber() { return new r("Invalid .aco file, wrong version number") } static InvalidFile() { return new r("Invalid .aco file") } static UnsupportedColorSpaceId(t) { return new r(`Unsupported color space id: ${t}`) } static UnsupportedColorSpaceName(t) { return new r(`Unsupported color space name: ${t}`) } static NotArrayBuffer() { return new r("First argument to readAcoFile must be an ArrayBuffer") } }; var x; (function (r) { r[r.rgb = 0] = "rgb", r[r.hsv = 1] = "hsv", r[r.cmyk = 2] = "cmyk", r[r.lab = 7] = "lab", r[r.grayscale = 8] = "grayscale" })(x || (x = {})); function L(r) { if (x[r] === void 0) throw h.UnsupportedColorSpaceId(r); return x[r] } function E(r) { if (x[r] === void 0) throw h.UnsupportedColorSpaceName(r); return x[r] } function m(r, t, e, i = !1) { return i ? r / e * t : r / t * e } function P(r, t, e = !1) { let i = [...r]; if (["rgb", "hsv", "lab"].includes(t)) if (i = i.slice(0, 3), t === "rgb") i = i.map(n => m(n, 65535, 255, e)); else if (t === "hsv") { let [n, o, s] = i; i = [m(n, 65535, 360, e), m(o, 65535, 100, e), m(s, 65535, 100, e)] } else t === "lab" && (i = i.map(n => m(n, 1e4, 100, e))); else t === "grayscale" ? i = i.slice(0, 1).map(n => m(n, 65535, 1, e)) : t === "cmyk" && (i = i.map(n => m(n, 65535, 1, e))); return i } function j(r, t = !1) { let e; t ? e = r : e = r.map(([o, s, u]) => [P(o, s, !0), s, u]); let i = new F, n = e.length; i.writeInt16(1), i.writeInt16(n); for (let [o, s] of e) { let u = E(s); i.writeInt16(u); for (let f = 0; f < 4; f++) { let a = o[f]; s === "lab" ? i.writeUint16(a) : i.writeInt16(a) } } i.writeInt16(2), i.writeInt16(n); for (let [o, s, u] of e) { let f = E(s); i.writeInt16(f); for (let a = 0; a < 4; a++) { let d = o[a]; s === "lab" ? i.writeUint16(d) : i.writeInt16(d) } D(i, u) } return i.buffer } function D(r, t) { let e = t.length; r.writeInt32(e + 1), r.writeString(t, "utf16be"), r.writeInt16(0) } function G(r, t = !1) { if (!(r instanceof ArrayBuffer)) throw h.NotArrayBuffer(); try { let e = new _(r), i, n = e.readInt16(), o = e.readInt16(), s, u = 4 + o * 10; if (e.byteLength > u && (e.setPosition(u), s = e.readInt16()), n === 1 && (i = 1), s === 2 && (i = 2), i === void 0) throw h.WrongVersionNumber(); e.setPosition(i === 1 ? 4 : 8 + o * 10); let f = []; for (let a = 0; a < o; a++) { let d = e.readInt16(), B = L(d), y = []; for (let S = 0; S < 4; S++)B === "lab" ? y.push(e.readInt16()) : y.push(e.readUint16()); y = y; let N = ""; i === 2 && (N = z(e)), f.push([y, B, N]) } return t ? f : f.map(([a, d, B]) => [P(a, d), d, B]) } catch (e) { throw e instanceof h ? e : (console.error(e), h.InvalidFile()) } } function z(r) { let t = r.readInt32(); return r.readString(t, "utf16be").slice(0, -1) } export { j as createAcoFile, G as readAcoFile };
